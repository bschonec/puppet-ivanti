#!/bin/sh
#
# This is the script generated by the Core to install Nix style agents. If envokes the nixconfig.sh
# script to actually do the installation but this script sets up the environment.  Below is a "Configuration"
# section which allows you to change the following:
#    VERBOSE       - How much information is written to the log file: Default $INFO - ERROR, WARN, INFO, DEBUG
#    CAPTURE_FILES - If set to 1, places an attempted installation in ${SAVE_DIR}
#    LDMS_CORE     - The core newtwork address - FQDN preferred
#    cronperiod    - The time period between inventory scans
#    SAVE_DIR      - Directory in which to store an attempted installation when ${CAPTURE_FILES} -eq 1
#    SAVE_FILES    - The list of files or regular expressions to save when capturing files
#
ERROR=0
WARN=1
INFO=2
DEBUG=3
script=`basename $0`
readonly ERROR
readonly WARN
readonly INFO
readonly DEBUG
readonly script

########################
# CONFIGURATION        #
########################
VERBOSE=$INFO
CAPTURE_FILES=0
LDMS_CORE=epmcore-02p.nfii.com
cronperiod=daily
SAVE_DIR="/tmp/.ldcfg-last/$$"
SAVE_FILES="*.tar.gz *.0 *.deb *.depot *.pkg *.rpm install.sh nixconfig.sh .ld-sleeper.sh wget*"

log() {
    prefix="`date`"
    [ $1 -eq $ERROR ] && prefix="`date`: ERROR"
    [ $1 -eq $WARN ] && prefix="`date`: Warning"
    [ $1 -eq $DEBUG ] && prefix="`date`: Debug($$)"
    if [ -z "${STDOUT_LOG:-}" ]; then
        [ $1 -le $VERBOSE ] && echo "${prefix}: ${2}"
    else
        [ $1 -le $VERBOSE ] && echo "${prefix}: ${2}" >> "${STDOUT_LOG}"
    fi
}

capture_files() {
    SAVE_FILES="${SAVE_FILES} ${STDOUT_LOG} ${STDOUT_RV} ${STDOUT_SCRIPT}"
    mkdir -p "$SAVE_DIR"
    for file in $SAVE_FILES; do
        log $DEBUG "Saving: ${file}"
        cp -p "${file}" "${SAVE_DIR}" 2>/dev/null
    done
}

bail()   { log $ERROR "SIG: Received ${1:-unknown}; bailing the installation"; exit 4; }
nobail() { log $INFO "SIG: Received ${1:-unknown}; ignoring"; }
for SIG in INT QUIT KILL; do { eval trap "\"bail $SIG\"" $SIG; } done
for SIG in HUP; do { eval trap "\"nobail $SIG\"" $SIG; } done

LDSIG="_LdCfG_InStAlL_"
for LDLOCKDIR in /tmp /var/lock /var/locks /var/tmp; do
    [ -d "$LDLOCKDIR" ] && break
done
log $DEBUG "LDLOCKDIR=$LDLOCKDIR"
log $DEBUG "testing for write permissions in $LDLOCKDIR"

if [ ! -w "$LDLOCKDIR" ]; then
    log $ERROR "user [`id -nu`] has insufficient permissions to install."
    exit 13
fi
LDLOCKFILE="$LDLOCKDIR/$LDSIG"
log $DEBUG "lockfile is $LDLOCKFILE"

LDPID_LOCK=0; LDPID_OLD=0; LDPID_COUNT=0
LDPID_PARENT=$$
LDPID_SLEEPTIME=60
LDPID_MATCHES=5
ACK=0; NAK=255

getpid() {
    LDPID_LOCK=`head -n 1 "$LDLOCKFILE" 2> /dev/null`
    LDPID_LOCK=`expr ${LDPID_LOCK} + 0`
    [ $LDPID_LOCK -gt 0 ] && return $ACK
    return $NAK
}

isvalid() {
    getpid || return $NAK
    [ -d "/proc/${LDPID_LOCK}" ] || return $NAK
    RV=`grep "$LDSIG" /proc/$LDPID_LOCK/cmdline 2> /dev/null | wc -l`
    RV=`expr $RV + 0`
    [ $RV -gt 0 ] || return $NAK
    return $ACK
}

ismatch() {
    LDPID_NEW=$1
    if [ $LDPID_NEW -eq $LDPID_OLD ]; then
        LDPID_COUNT=`expr ${LDPID_COUNT} + 1`
    else
        LDPID_OLD=$LDPID_NEW
        LDPID_COUNT=0
    fi
    return $LDPID_COUNT
}

forcelock() {
    echo $$ > "$LDLOCKFILE" || exit $?
}

trylock() {
    if [ -f "$LDLOCKFILE" ]; then
        getpid || return $NAK
        [ $LDPID_LOCK -eq $$ ] && return $ACK
        [ $LDPID_LOCK -eq $LDPID_PARENT ] || return $NAK
    fi
    forcelock
    sleep 1
    getpid || return $NAK
    [ $LDPID_LOCK -eq $$ ] || return $NAK
    return $ACK
}

unlock() {
    LDPID_LOCK=`head -n 1 "$LDLOCKFILE" 2> /dev/null`
    LDPID_LOCK=`expr ${LDPID_LOCK} + 0`
    [ $LDPID_LOCK -gt 0 ] && [ $LDPID_LOCK -ne $1 ] && echo "AARGH: was $LDPID_LOCK, expected $1" && return
    RemoveFiles "$LDLOCKFILE"
}

atexit() {
    [ $# -gt 0 ] && [ -z "${EXITFUNCS:-}" ] && trap doatexit EXIT &&
    log $DEBUG "trapping EXIT for atexit use"
    for A in "$@"; do
        log $DEBUG "adding atexit for [$A]"
        [ -n "${EXITFUNCS:=}" ] && EXITFUNCS="$EXITFUNCS;"
        EXITFUNCS="${EXITFUNCS:-}$A"
    done
}

doatexit() {
    [ -n "${EXITFUNCS:=}" ] && eval $EXITFUNCS
}

spawn() {
    CMD="$1 $LDSIG $$"
    shift
    for A in $@; do CMD="$CMD \"$A\""; done
    if [ -n "${SPAWN_EXTRAS:-}" ]; then
        SLEEPER=$LDPWD/.ld-sleeper.sh
        cat - > $SLEEPER <<-EOF.xxx
#!/bin/sh
sleep 4
/bin/sh "$CMD ${SPAWN_EXTRAS:-}"
RV=\$?
echo "RV from child cmd: \$RV"
EOF.xxx
        TMP="nohup /bin/sh $SLEEPER &"
        log $DEBUG "cloning self into background: $TMP"
        eval $TMP
        PID=$!
        RV=$?
        log $DEBUG "clone pid($PID) started with $RV"
        log $DEBUG "saving clone pid($PID) to $STDOUT_PID"
        echo "$PID" > $STDOUT_PID
        log $DEBUG "requesting that task-handler exec $STDOUT_SCRIPT to finish"
        echo "### LdReExEc: $STDOUT_SCRIPT"
    else
        log $DEBUG "cloning self and waiting ..."
        /bin/sh $CMD
        RV=$?
    fi
    log $DEBUG "exiting primary with $RV"
    exit $RV
}

scribble_setup() {
    [ -n "${LDPWD:-}" ] || LDPWD=`pwd`
    STDOUT_PATH="$LDPWD/.stdout"
    log $DEBUG "setting default stdout path to $STDOUT_PATH"
    STDOUT_LOG="$STDOUT_PATH.log"
    log $DEBUG "spawn logfile is $STDOUT_LOG"
    STDOUT_SCRIPT="$STDOUT_PATH.sh"
    STDOUT_PID="$STDOUT_PATH.pid"
    STDOUT_RV="$STDOUT_PATH.rv"
}

scribble() {
    INTERVAL=5
    log $DEBUG "scribbling watcher script $STDOUT_SCRIPT"
    cat - > $STDOUT_SCRIPT <<-EOF.stdout
#!/bin/sh
VERBOSE=$INFO
DEBUG=$DEBUG
[ \$VERBOSE -eq \$DEBUG ] && echo "debug(\$\$): starting \$0 as \$\$ at" \`date "+%Y%m%d+%H%M%S"\`
TIMEOUT=3600
[ \$VERBOSE -eq \$DEBUG ] && echo "debug(\$\$): setting timeout to \$TIMEOUT"
LDPWD="$LDPWD"
[ \$VERBOSE -eq \$DEBUG ] && echo "debug(\$\$): working in \$LDPWD"
STDOUT_LOG="$STDOUT_LOG"
[ \$VERBOSE -eq \$DEBUG ] && echo "debug(\$\$): logfile will be \$STDOUT_LOG"
STDOUT_PID="$STDOUT_PID"
[ \$VERBOSE -eq \$DEBUG ] && echo "debug(\$\$): using pid from file \$STDOUT_PID"
PID=\`$HEAD -n 1 \$STDOUT_PID\`
[ \$VERBOSE -eq \$DEBUG ] && echo -n "debug(\$\$): waiting on pid \$PID: "
sleep 10
while [ -f "\$STDOUT_PID" ]; do
    [ \$VERBOSE -eq \$DEBUG ] && echo -n "."
    sleep $INTERVAL
    TIMEOUT=`expr \$TIMEOUT - \$INTERVAL`
    [ \$TIMEOUT -gt 0 ] && [ -d "/proc/\${PID}" ] || rm -f \$STDOUT_PID
done
[ \$VERBOSE -eq \$DEBUG ] && echo " done"
[ \$TIMEOUT -gt 0 ] || echo "Timed out waiting for install to finish"
[ \$VERBOSE -eq \$DEBUG ] && echo "debug(\$\$): dumping log \$STDOUT_LOG"
cat \$STDOUT_LOG
STDOUT_RV="$STDOUT_RV"
RV=99
[ -f "\$STDOUT_RV" ] && RV=`head -n 1 \$STDOUT_RV`
[ \$VERBOSE -eq \$DEBUG ] && echo "debug(\$\$): return value from \$STDOUT_RV was \$RV"
exit \$RV
EOF.stdout
    if [ -f $STDOUT_SCRIPT ]; then
        chmod a+x $STDOUT_SCRIPT
    else
        log $WARN "Creation of watcher script $STDOUT_SCRIPT failed!"
    fi
    SPAWN_EXTRAS="&>$STDOUT_LOG"
    log $DEBUG "SPAWN_EXTRAS=${SPAWN_EXTRAS:-}"
}

clone_exit() {
    RV="$1"
    shift
    echo "$RV" > ${STDOUT_RV:=/tmp/landesk.missing.rv}
    log $DEBUG "wrote rv($RV) to $STDOUT_RV"
    for A in $@; do echo "$A"; done
    [ "${CAPTURE_FILES}" -ne 0 ] && capture_files
    log $INFO "Exiting with return code $RV"
    exit $RV
}

RemoveFiles() {
    for A in $@; do
        if [ -f "$A" ]; then
            log $DEBUG "Removing file $A"
            rm -f "$A" 2> /dev/null
        fi
    done
}

if [ "${1:-notset}" = "$LDSIG" ]; then
    LDPID_PARENT=$2
    log $DEBUG "I'M A CLONE! orig($LDPID_PARENT)"
    shift 2
    scribble_setup
    log $DEBUG "verifying this is the instance that won the lock"
    trylock || clone_exit 26 "Failed to get the lock; exiting."
    atexit "RemoveFiles $STDOUT_PID"
    atexit "unlock $$"
else
    /bin/date
    [ -x "$0" ] || chmod a+x "$0"

    LDDIR=`echo $0 | sed "s/\(.*\)\/${script}$/\1/"`
    LDPWD=`pwd`
    [ "x$LDDIR" != "x." ] && [ "x$LDDIR" != "x$LDPWD" ] && cd "$LDDIR"

    LDPWD=`pwd`
    BASE="${script}"

    while true; do
        trylock && break
        if isvalid; then
            log $ERROR "another configuration task already running; aborting this job"
            exit 16
            log $INFO "system busy; waiting ..."
            sleep $LDPID_SLEEPTIME
        else
            ismatch $LDPID_LOCK
            if [ $LDPID_COUNT -ge $LDPID_MATCHES ]; then
                forcelock
                log $DEBUG "lockfile was stale; clobbered"
            fi
            [ $LDPID_COUNT -eq 0 ] && log $DEBUG "found a lockfile that appears stale"
            sleep 1
        fi
    done

    scribble_setup
    for A in $@; do
        eval B="echo $A | sed 's/\(NOOEM\)=.*/\1/'"
        [ "${B}" = "NOOEM" ] && scribble
    done
    spawn "${LDPWD}/${script}" "${@:-}"
fi

STAGING=`echo $0 | sed "s/\(.*\)\/${script}$/\1/"`

cd "${STAGING}"
if [ $? -ne 0 ]; then
        clone_exit 20 "Unable to change to staging dir $STAGING"
        exit 20
fi

export cronperiod

if [ $VERBOSE -eq $DEBUG ]; then
    /bin/sh "${STAGING}/nixconfig.sh" -d -a "${LDMS_CORE}" -l "${STDOUT_LOG}"
else
    /bin/sh "${STAGING}/nixconfig.sh" -a "${LDMS_CORE}" -l "${STDOUT_LOG}"
fi

RV=$?

if [ $RV -ne 0 ]; then
    clone_exit $RV "Failed to properly install the client."
else
    clone_exit 0 "Successfully finished installing client."
fi
